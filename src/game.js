import W from './w.custom.esm.js';
import input from './input.js';
import { makeStarSystem, updateSystem } from './star-system.js';
import { BG_COLOR, FLAME_ON_COLOR, FLAME_OFF_COLOR, SCAN_COLOR,
} from './colors.js';
import { vec3 } from './Vector3.js';
import { addPyramid, addRect, addSphere } from './w-shapes.js';
import { makeTextures } from './textures.js';
// import { zzfx } from 'zzfx';
import { zzfx } from './libs/ZzFX.js';
import { $, $id, $html, flashBorder } from './dom.js';
import { SHIP_SIZE, FAR, SPACE_SIZE, SCAN_SIZE } from './scale.js';
import { getDirectionUnit, loop, clamp, lerp, rotateByDegree, addAngles, uid, rand, pick, wait } from './utils.js';

const { min, max, PI, round, abs } = Math;

const g = {
	W,
	input,
	paused: 0,
	nextEnter: 0,
	ogKlaxShipCount: 0,
};
let sys;
let textures = {};
const MAX_PARTS = 7;
const MAX_VEL = 800;
const VEL_FRICTION = .25; // Friction per tick (0.016)

// const sun = { rx: 0, ry: 0, ry: 0 };

const t = 1000 / 60;
const camOffset = { back: -SHIP_SIZE * 5, up: SHIP_SIZE * 2, rx: 80, ry: 0, rz: 0, zoom: 1 };
const cam = { fov: 30, targetFov: 30, lastFov: 31, aspect: 1, near: 0.5, far: FAR };
let rotation = 0;
const STEER_X_MIN = -90 - 90;
const STEER_X_MAX = -90 + 90;
const steer = { rx: -90, ry: 0, rz: 0 };

const achievements = [
	'Check steering: [Tab] to toggle mouse-lock', // 0
	'Scan: Hold [C]', // 1
	'Thrusters: [W] and [S]', // 2
	'Fire weapons: [Space] or [Click]', // 3
	'Boost: Hold [Shift]', // 4
	'Klaxonian Ships Destroyed: {K} / {S}', // 5
	'Ring Repair Parts: {P} / {M}', // 6
].map((t) => ({ t, done: 0 }));

function achieve(i) {
	if (i !== undefined) {
		if (achievements[i].done) return;
		achievements[i].done = 1;
	}
	const left = sys.klaxShips.filter((k) => k.hp > 0).length;
	const kills = g.ogKlaxShipCount - left;
	if (left === 0) achievements[5].done = 1;
	if ((ship.inv.parts || 0) >= MAX_PARTS) achievements[6].done = 1;
	updateAchievements(kills);
	if (achievements.length === achievements.filter((a) => a.done).length) {
		dialog('You did it! With those parts we should be able to get the Ring powered up again.<p>Thank you!</p>');
	}
}

function updateAchievements(kills) {
	const html = achievements.map(
		({ t, done }) => `<li class="${ done ? 'done' : ''}">${
			t.replace('{K}', kills)
				.replace('{S}', g.ogKlaxShipCount)
				.replace('{P}', ship.inv.parts || 0)
				.replace('{M}', MAX_PARTS)
		}</li>`,
	).join('');
	$html('goals', html);
}

function gameOver() {
	g.paused = 1;
	input.unlock();
	$('main').classList.add('end');
	$id('end').style.display = 'flex';
}

function title() {
	g.paused = 1;
	W.camera({ x: 0, y: 0, z: 0, rx: -13 });
	$id('hi').style.display = 'flex';
	g.nextEnter = () => titleDone();
}

function titleDone() {
	$id('hi').style.display = 'none';
	return dialog(
		`<p>A Star-Hopper ship! You heard our distress call? ðŸ“¡ We're under attack by a Klaxonian fleet!</p>`
		+ `<p>The entire sector is dependent on the POWER generated by our Bunson Ring. âš¡`
		+ `Please rescue us and help get the Ring operational again.</p>`
	);
}

function setupCanvasSize(c) {
	const w = c.clientWidth;
	const h = c.clientHeight
	if (w > h) {
		cam.aspect = w/h;
		c.height = min(w, 800);
		c.width = w / cam.aspect;
	} else {
		// Make it square
		c.width = c.height = min(w, 800);
		cam.aspect = 1;
	}
	// const minDim = max(min(ogW, ogH), 800);
	// const aspect = ogW / ogH;
	// c.width = minDim * aspect;
	// c.height = minDim * aspect;
	// console.log(aspect, ogW, ogH, c.width, c.height);
	// cam.aspect = aspect;
}

function dialog(text) {
	zzfx(...[2.36,0,130.8128,.02,.51,.2,,1.91,,,,,.08,,,,.04,.5,,.39]);
	g.paused = 1;
	const c = $id('dialog').classList;
	const s = $id('goals').style;
	s.opacity = '0';
	input.unlock();
	// console.log(textures.rabbit);
	$html('pic', `<img src="${textures.rabbit.toDataURL()}" />`);
	$html('txt', text + '<i data-key="Enter">Close [Enter]</i>');
	c.add('show');
	W.camera({ x: 0, y: 100, z: 0, a: 200 }, 500);
	g.W.move({ n: 'system', x: 1000, y: -500, z: -2500, a: 2000 }, 500);
	return g.nextEnter = () => {
		s.opacity = '1';
		c.remove('show');
		g.paused = 0;
		$('main').classList.remove('ui--off');
	};
}


function setup() {
	const c = $id('canvas');
	setupCanvasSize(c);
	input.setup({
		lockElt: c,
		keys: {
			Tab: () => { achieve(0); input.toggleLock(); },
			p: () => {
				g.paused = !g.paused;
			},
			Enter: () => {
				if (g.nextEnter) g.nextEnter = g.nextEnter();
			},
		}
	});
	textures = makeTextures();

	c.addEventListener('click', () => {
		input.lock();
	});
	W.reset(c);
	W.clearColor(BG_COLOR);
	// W.camera({ z: 5000 });
	W.light({ x: -1, y: -1.2, z: .2 }); // Set light direction: vector direction x, y, z
	W.ambient(0.8); // Set ambient light's force (between 0 and 1)
	// New shapes
	addRect('plank', { y: 10, z: 5, x: .3 });
	addRect('longRect', { x: 0.2, y: 0.2 });
	addRect('longerRect', { x: 0.2, y: 0.2, z: .7 });
	addRect('cube');
	addPyramid('pyramid');
	addPyramid('longPyramid', { y: .8 });
	addSphere('sphere');
	addSphere('simpleSphere', { precision: 6 });
	addSphere('ufo', { y: 3, precision: 10 });
	// addRect('rect', { y: 1 });

	sys = makeStarSystem(W, SPACE_SIZE);
	['renderables', 'ship', 'physicsEnts', 'klaxShips'].forEach((k) => {
		window[k] = sys[k];
		g[k] = sys[k];
	});

	sys.klaxShips.forEach((k, i) => {
		W.billboard({ n: `scan${i}`, g: 'system', x: k.x, y: k.y, z: k.z, size: 100, b: SCAN_COLOR });
	});
	g.ogKlaxShipCount = sys.klaxShips.length;
	achieve();
}

function thrust(o, amount = 0) {
	const { x, y, z } = getDirectionUnit(o).scale(amount);
	o.thrust = { x, y, z};
}

function outOfBounds(o) {
	const boundDirs = ['x', 'y', 'z'].filter((a) => o[a] >= SPACE_SIZE || o[a] <= -SPACE_SIZE);
	return boundDirs.length > 0;
}

function physics(o, sec) {
	// If no thrust then apply friction (unrealistic in space? let's blame it on lots of star dust)
	let { friction = 1 } = o;
	friction *= VEL_FRICTION;
	if (outOfBounds(o)) friction *= 10;
	// const friction = (typeof o.friction === 'number') ? VEL_FRICTION * o.friction : VEL_FRICTION;
	const velVector = vec3(o.vel);
	const F = vec3(o.thrust || undefined);
	const acc = F.scale(1 / (o.mass || 1));
	o.vel = velVector
		.sub(velVector.normalize(friction)) // friction is an acceleration of sorts, not mass dependent
		.add(acc.scale(1/sec)); // add acceleration per time
	const spd = o.vel.length();
	if (spd > MAX_VEL) o.vel = o.vel.normalize(MAX_VEL);
	else if (spd < 0.0001) o.vel = vec3();
	['x', 'y', 'z'].forEach((a) => {
		// This "* sec" calculation seems wrong but don't want to mess with it right now
		o[a] = clamp(o[a] + o.vel[a] * sec, -SPACE_SIZE, SPACE_SIZE);
		if (outOfBounds(o)) {
			if (o.decay) o.decay = 0;
			// console.log(o.n, 'edge');
		}
	});
}

function dmg(a, b) {
	if (a.damage && b.hp) {
		const isShipHurt = (b === ship)
		console.log('Damage', b.n);
		b.hp -= a.damage;
		if (a.destroyOnDamage) a.decay = 0;
		if (b.hp <= 0) {
			console.log('Destroy', b.n);
			b.decay = 0;
			if (b.drops) {
				b.drops.forEach((drop) => ship.inv[drop] = (ship.inv[drop] || 0) + 1);
			}
			if (b.explodes) spawnExplosion(b);
			achieve();
		} else {
			spawnExplosion({ x: b.x, y: b.y, z: b.z, explodes: { count: 10 }});
		}
		const vol = isShipHurt ? 1.5 : .7;
		zzfx(...[vol,,416,.02,.21,.52,4,2.14,.2,,,,,1.7,,.9,,.44,.12,.23]);
		if (isShipHurt) flashBorder('canvas');
	}
	a.aggro += 1;
	b.aggro += 1;
	a.shieldOpacity += 5;
	b.shieldOpacity += 5;
};

function collide(e1, e2, dist) {
	// Set flags
	e1.collided = e2;
	e2.collided = e1;
	// Damage
	dmg(e1, e2);
	dmg(e2, e1);
	// Un-overlap
	const collisionVector = vec3(e2).sub(e1).normalize();
	const overlap = e1.r + e2.r - dist;
	// Move each sphere back by half the overlap
	const reverseOverlapVector = collisionVector.scale(overlap / 2);
	vec3(e1).sub(reverseOverlapVector).copyTo(e1);
	vec3(e2).add(reverseOverlapVector).copyTo(e2);
	// Set new velocities
	['x', 'y', 'z'].forEach((a) => {
		const m1 = e1.mass || 1;
		const m2 = e2.mass || 1;
		const tm = m1 + m2; // total mass
		const v1 = e1.vel[a];
		const v2 = e2.vel[a];
		// From https://en.wikipedia.org/wiki/Elastic_collision#Equations
		e1.vel[a] = (
			((m1 - m2) / tm) * v1
			+ ((2 * m2) / tm) * v2
		) * 1; // restitution
		e2.vel[a] = (
			((2 * m1) / tm) * v1
			+ ((m2 - m1) / tm) * v2
		) * 1;
		// console.log(a, 'before', v1, v2, '\nafter', e1.vel[a], e2.vel[a]);
	});
}

function checkCollisions(ents) {
	loop(ents.length, (i) => {
		checkCollisionOne(ents[i], ents);
	});
}

function pass(a, b) {
	return (a.passthru && a.passthru.includes(b.passType));
}

function checkCollisionOne(e1, ents) {
	if (e1.collided) return;
	loop(ents.length, (w) => {
		const e2 = ents[w];
		if (pass(e1, e2) || pass(e2, e1) || e1 === e2)  return;
		if (e2.collided) return;
		const d = vec3(e1).distance(e2);
		if (d <= (e1.r + e2.r)) collide(e1, e2, d);
	});
}

function move(things = {}) {
	Object.keys(things).forEach((key) => {
		W.move({ n: key, ...things[key] }, 0);
	});
}

function cool(o, prop, sec) {
	o[prop] = max(o[prop] - sec, 0);
}

function steerRotation(o, steer, strafe = 0) {
	const { steerPercent = 0.01 } = o;
	['rx', 'ry', 'rz'].forEach((k) => o[k] = lerp(steerPercent, o[k], steer[k]));
	// console.log(o.ry, strafe, o.ry + strafe, steer.ry);
	if (strafe) o.ry = lerp(0.1, o.ry, steer.ry + strafe);
}

function updateKlaxShip(k, sec) {
	if (k.decay <= 0 || k.hp <= 0) {
		// console.warn('destroyed ship');
		return;
	}
	const pos = vec3(k);
	const dist = pos.distance(ship);
	if (dist > k.sight * 2) k.aggro = max(0, k.aggro -= 0.1);
	else if (dist <= k.sight) k.aggro = max(1, k.aggro);
	if (!k.aggro) return;
	// Aggro actions
	const steer = pos.toWAngles(ship);
	steerRotation(k, steer);
	// k.rx = lerp(0.01, k.rx, rx);
	// k.ry = lerp(0.01, k.ry, ry);
	// k.rz = lerp(0.01, k.rz, rz);
	if (k.thrustCooldown) {
		cool(k, 'thrustCooldown', sec);
	} else {
		thrust(k, k.thrustForce);
		k.thrustCooldown = rand(.5, 1);
	}
	if (k.fireCooldown) {
		cool(k, 'fireCooldown', sec);
	} else {
		spawnPlasma('klaxPlasma', k, 'klaxPlasma', ['klaxShip', 'klaxPlasma', 'plasma']);
		k.fireCooldown = rand(0.3, 3);
	}
}

const basePlasmaThrustScale = .001;
const PROJECTILE_TYPES = {
	plasma: { vScale: 45, tScale: basePlasmaThrustScale * 4, damage: 1, size: 2,
		sound: [,.1,295,.02,.01,.08,,1.72,-3.5,.2,,,,.2,,,.08,.62,.09] },
	photon: { vScale: 25, tScale: basePlasmaThrustScale * 1.2, damage: 3, size: 2,
		sound: [2.06,.35,212,.05,.08,.01,,1.66,-4.8,.2,50,,,1.7,,.5,.28,.65,.02] },
	klaxPlasma: { vScale: 45, tScale: basePlasmaThrustScale * 2, damage: 1, size: 10,
		sound: [.3,.4,241,.04,.03,.08,,.46,-7.7,,,,,,,.2,,.53,.05,.2],
	},
};

function spawnPlasma(typeKey, from, passType, passthru) {
	const { vScale, tScale, damage, size, sound } = PROJECTILE_TYPES[typeKey];
	// if (tScale < VEL_FRICTION) console.warn('Not enough thrust to overcome friction');
	const t = textures[typeKey];
	const u = getDirectionUnit(from);
	const { x, y, z } = vec3(from).add(u.normalize(from.size));
	const v = u.scale(vScale).add(from.vel);
	zzfx(...sound);
	const plasma = {
		n: typeKey + passType + uid(),
		g: 'system',
		passType,
		x, y, z,
		vel: { ...v },
		thrust: { ...u.scale(tScale) },
		// friction: 0,
		decay: 6,
		damage,
		r: 5,
		passthru,
		mass: 0.01,
		size,
		destroyOnDamage: 1,
	};
	physicsEnts.push(plasma);
	renderables[plasma.n] = plasma;
	W.billboard({ ...plasma, t });
}

function spawnExplosion(where) {
	let { x, y, z, explodes = {} } = where;
	const { count = 20, size = 2, colors = ['464040', 'de8b6f', 'b0455a'] } = explodes;
	console.log('Exploding for', where.n, count);
	loop(count, () => {
		const vel = vec3(where.vel || { x: 0, y: 0, z: 0 });
		['x', 'y', 'z'].forEach((w) => {
			vel[w] += rand(-20, 20);
		});
		const explosion = {
			n: `explosion${uid()}`,
			x: x + rand(-.5, .5),
			y: y + rand(-.5, .5),
			z: z + rand(-.5, .5),
			vel,
			decay: rand(1, 10),
			r: 1,
			g: 'system',
			size: max(size + rand(-size/2, size/2), .2),
			passType: 'dust',
			passthru: ['dust'],
			mass: 0.01,
			b: pick(colors),
			destroyOnDamage: 1,
		};
		physicsEnts.push(explosion);
		renderables[explosion.n] = explosion;
		W.billboard({ ...explosion });
	});
}

function updateUI() {
	const v = vec3(ship.vel);
	const dir = (v.x > v.y && v.x > v.z) ? 'X' : (
		(v.y > v.x && v.y > v.z) ? 'Y' : 'Z'
	);
	const html = '<b>' + [
		`Velocity: ${round(v.length())} (${dir})`,
		`Pitch: ${round(steer.rx + 90)}, Yaw: ${round(steer.ry) % 360}`,
		`Hull: ${ship.hp}`,
	].join('</b><b>') + '</b>';
	$html('si', html);
}

function removeFromArray(n, arr) {
	const i = arr.findIndex((o) => o.n === n);
	if (i !== -1) arr.splice(i, 1);
}

function zoom(n) {
	camOffset.zoom = clamp(camOffset.zoom + n, 0, 100);
}

function update() {
	if (g.paused) return;
	const sec = t / 1000;
	rotation = (rotation + sec) % 360;

	// Handle inputs and update player ship
	const { down } = input;
	if (down[']']) cam.targetFov += .5;
	if (down['[']) cam.targetFov -= .5;
	const wheel = input.getWheel();
	if (down['-'] || wheel > 0) zoom(.1);
	if (down['='] || down['+'] || wheel < 0) zoom(-.1);
	if (down.p) return;
	const strafe = (down.a) ? 90 : (down.d ? -90 : 0);

	const boost = down.Shift ? 2 : 1;
	let thrustAmount = 0; 
	if (boost > 1) achieve(4);
	if (down.s) {
		thrustAmount = ship.thrustForce * boost * -.5;
		down.w = 0;
	} else if (down.w) {
		thrustAmount = ship.thrustForce * boost;
	}
	thrust(ship, thrustAmount);
	const flameColor = (thrustAmount > 0) ? FLAME_ON_COLOR : FLAME_OFF_COLOR;
	W.move({ n: 'sFlame1', b: flameColor });
	W.move({ n: 'sFlame2', b: flameColor });
	if (thrustAmount === 0) {
		W.delete('sIgnite1');
		W.delete('sIgnite2');
	} else {
		const vol = (boost > 1) ? .15 : .1;
		const bitCrush = (boost > 1) ? .2 : .8;
		zzfx(...[vol,,794,.02,.3,.32,,3.96,,.7,,,.16,2.1,,bitCrush,.1,.31,.27]);
		achieve(2);
		const base = { g: 'ship', y: SHIP_SIZE * -1.31, rx: 70, size: .2, t: textures.tf };
		W.billboard({ ...base, n: 'sIgnite1', x: -SHIP_SIZE * 1.1  });
		W.billboard({ ...base, n: 'sIgnite2', x: SHIP_SIZE * 1.1 });
	}
	const click = input.getClick();
	if (ship.fireCooldown === 0 && (
		down[' '] || (click && click.locked)
	)) {
		achieve(3);
		spawnPlasma((click && click.right) ? 'photon' : 'plasma', ship, 'plasma', ['ship', 'plasma', 'klaxPlasma']);
		ship.fireCooldown = 0.3;
	}
	if (down.f) {
		spawnExplosion(ship, ship.explodes);
	}
	// Scan
	if (down.c) achieve(1);
	klaxShips.forEach((k, i) => {
		W.move({ n: `scan${i}`, x: k.x, y: k.y, z: k.z, size: SCAN_SIZE,
			b: (k.hp > 0 && down.c) ? SCAN_COLOR : '0000',
		});
	});

	// Player cool down
	ship.fireCooldown = max(ship.fireCooldown - sec, 0);

	// Do enemy thrust, rotation, cooldowns, and AI
	klaxShips.forEach((k) => updateKlaxShip(k, sec));

	// Do collisions
	checkCollisions(physicsEnts);
	// Do physics, and clear collided flag
	physicsEnts.forEach((o) => {
		o.collided = 0;
		physics(o, sec);
	});

	// Check for player death
	if (ship.hp <= 0) return gameOver();
	
	// Do steering
	{
		// const { ry, rx } = steer;
		const lockMove = input.getLockMove();
		// if (lockMove.x || lockMove.y) console.log(lockMove);
		steer.ry -= lockMove.x / 10;
		steer.rx = min(max(steer.rx - lockMove.y / 10, STEER_X_MIN), STEER_X_MAX);
		// steer.rz += down.a ? -2 : (down.d ? 2 : 0);
		// console.log({ ...steer });
		steerRotation(ship, steer, strafe);
	}
	{
		const unit = rotateByDegree(
			vec3(0, camOffset.back, camOffset.up).scale(camOffset.zoom), steer);
		// TODO: only add cam if fov or aspect ratio has changed
		const speedFov = (!thrustAmount) ? 0 : (
			thrustAmount < 0 ? -2 : (
				(boost > 1) ? 10 : 1
			)
		);
		cam.fov = lerp(0.1, cam.fov, cam.targetFov + speedFov);
		const fovChanged = abs(cam.fov - cam.lastFov) > 0.001;
		cam.lastFov = cam.fov;
		let camSettings = { ...unit, ...addAngles(camOffset, steer), a: 100 };
		if (fovChanged) camSettings = { ...camSettings, ...cam };
		W.camera(camSettings);
	}
	{
		const { x, y, z, rx, ry, rz } = ship;
		W.move({ n: 'ship', rx, ry, rz });
	}

	// Decay
	Object.keys(renderables).forEach((k) => {
		const p = renderables[k];
		if (typeof p.decay === 'number') {
			p.decay -= sec;
			if (p.decay <= 0) {
				if (p.isGroup) {
					// We don't know the group's children, so we can't just delete the group
					// otherwise the children will still get rendered
					W.move({ n: p.n, x: FAR * 2 });
				} else {
					W.delete(p.n);
				}
				removeFromArray(p.n, physicsEnts);
				removeFromArray(p.n, klaxShips);
				delete renderables[k];
			}
		}
	});

	// Animate the system and renderables
	move({
		...renderables,
		system: { x: -ship.x, y: -ship.y, z: -ship.z, a: t },
		...updateSystem(t),
	});
	updateUI();
}

addEventListener('DOMContentLoaded', async () => {
	setup();
	await wait(30);
	update();
	await wait(30);
	title();
	// titleDone();
	setInterval(update, t);
});

window.g = g;
