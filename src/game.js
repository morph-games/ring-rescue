import W from './w.custom.esm.js';
import input from './input.js';
import { makeStarSystem, updateSystem } from './star-system.js';
import { BG_COLOR, FLAME_ON_COLOR, FLAME_OFF_COLOR, SCAN_COLOR,
} from './colors.js';
import { vec3 } from './Vector3.js';
import { addPyramid, addRect, addSphere } from './w-shapes.js';
import { makeTextures } from './textures.js';
// import { zzfx } from 'zzfx';
import { zzfx } from './libs/ZzFX.js';
import { $, $id, $html, flashBorder } from './dom.js';
import { SHIP_SIZE, FAR, SPACE_SIZE, SCAN_SIZE } from './scale.js';
import { getDirectionUnit, loop, clamp, lerp, rotateByDegree, addAngles, uid,
	rand, pick, wait
} from './utils.js';

const { min, max, PI, round, abs, floor } = Math;

const g = {
	W,
	input,
	paused: 0,
	trail: 0,
	nextEnter: 0,
	ogKlaxShipCount: 0,
	klaxShipLeft: 0,
	start() { this.i = setInterval(update, t); },
	stop() { clearInterval(this.i); },
	tick: 0,
};
let sys;
let textures = {};
const MAX_PARTS = 7;
const MAX_VEL = 800;
const VEL_FRICTION = .25; // Friction per tick (0.016)
const PHYSICS_COLLIDABLE = 1, PHYSICS_NON_COLLIDABLE = 2;

// const sun = { rx: 0, ry: 0, ry: 0 };

const t = 1000 / 60;
const camOffset = { back: -SHIP_SIZE * 5, up: SHIP_SIZE * 2, rx: 80, ry: 0, rz: 0, zoom: 1 };
const cam = { fov: 30, targetFov: 30, lastFov: 31, aspect: 1, near: 0.5, far: FAR };
let rotation = 0;
const STEER_X_MIN = -90 - 90;
const STEER_X_MAX = -90 + 90;
const steer = { rx: -90, ry: 0, rz: 0 };

const achievements = [
	'Check steering: [Tab] to toggle mouse-lock', // 0
	'Scan: Hold [C]', // 1
	'Thrusters: [W] and [S]', // 2
	'Fire weapons: [Click], [F], or [R]', // 3
	'Boost: Hold [Shift] with [W] or [S]', // 4
	'Shields: [Space]', // 5
	'Klaxonian Ships Destroyed: {K} / {S}', // 6
	'Ring Repair Parts: {P} / {M}', // 7
].map((t) => ({ t, done: 0 }));

function achieve(i) {
	if (i !== undefined) {
		if (achievements[i].done) return;
		achievements[i].done = 1;
	}
	const kills = g.ogKlaxShipCount - g.klaxShipLeft;
	if (g.klaxShipLeft <= 0) achievements[6].done = 1;
	if ((ship.inv.parts || 0) >= MAX_PARTS) achievements[7].done = 1;
	updateAchievements(kills);
	if (achievements.length === achievements.filter((a) => a.done).length) {
		dialog('You did it! With those parts we should be able to get the Ring powered up again.<p>Thank you!</p><p>(Refresh page to play again.)');
	}
}

function updateAchievements(kills) {
	const html = achievements.map(
		({ t, done }) => `<li class="${ done ? 'done' : ''}">${
			t.replace('{K}', kills)
				.replace('{S}', g.ogKlaxShipCount)
				.replace('{P}', ship.inv.parts || 0)
				.replace('{M}', MAX_PARTS)
		}</li>`,
	).join('');
	$html('goals', html);
}

function gameOver() {
	g.paused = 1;
	input.unlock();
	$('main').classList.add('end');
	$id('end').style.display = 'flex';
}

function title() {
	g.paused = 1;
	W.camera({ x: 0, y: 0, z: 0, rx: -13 });
	$id('hi').style.display = 'flex';
	g.nextEnter = () => titleDone();
}

function titleDone() {
	$id('hi').style.display = 'none';
	return dialog(
		`<p>A Star-Hopper ship! You heard our distress call? ðŸ“¡ We're under attack by a Klaxonian fleet!
		They've disabled our defenses and solar farms.</p>`
		+ `<p>The entire sector is dependent on the POWER generated by our Bunson Ring. âš¡`
		+ `Please rescue us and help get the Ring operational again.</p>`
	);
}

function setupCanvasSize(c) {
	const w = c.clientWidth;
	const h = c.clientHeight
	if (w > h) {
		cam.aspect = w/h;
		c.height = min(w, 800);
		c.width = w / cam.aspect;
	} else {
		// Make it square
		c.width = c.height = min(w, 800);
		cam.aspect = 1;
	}
	// const minDim = max(min(ogW, ogH), 800);
	// const aspect = ogW / ogH;
	// c.width = minDim * aspect;
	// c.height = minDim * aspect;
	// console.log(aspect, ogW, ogH, c.width, c.height);
	// cam.aspect = aspect;
}

function dialog(text) {
	zzfx(...[2.36,0,130.8128,.02,.51,.2,,1.91,,,,,.08,,,,.04,.5,,.39]);
	g.paused = 1;
	const c = $id('dialog').classList;
	const s = $id('goals').style;
	s.opacity = '0';
	input.unlock();
	// console.log(textures.rabbit);
	$html('pic', `<img src="${textures.rabbit.toDataURL()}" />`);
	$html('txt', text + '<i data-key="Enter">Close [Enter]</i>');
	c.add('show');
	W.camera({ x: 0, y: 100, z: 0, a: 200 }, 500);
	W.move({ n: 'system', x: 1000, y: -500, z: -2500, a: 2000 }, 500);
	return g.nextEnter = () => {
		zzfx(...[.5,,259,.02,.02,.01,2,.19,,,-48,.01,,,3.4,.8,,.13,.01]);
		s.opacity = '1';
		c.remove('show');
		g.paused = 0;
		$('main').classList.remove('ui--off');
	};
}


function setup() {
	const c = $id('canvas');
	setupCanvasSize(c);
	input.setup({
		lockElt: c,
		keys: {
			Tab: () => { achieve(0); input.toggleLock(); },
			p: () => { g.paused = !g.paused; },
			t: () => { g.trail = !g.trail; },
			Enter: () => {
				if (g.nextEnter) g.nextEnter = g.nextEnter();
			},
		}
	});
	textures = makeTextures();

	c.addEventListener('click', () => {
		input.lock();
	});
	W.reset(c);
	W.clearColor(BG_COLOR);
	// W.camera({ z: 5000 });
	W.light({ x: -1, y: -1.2, z: .2 }); // Set light direction: vector direction x, y, z
	W.ambient(0.8); // Set ambient light's force (between 0 and 1)
	// New shapes
	addRect('plank', { y: 10, z: 5, x: .3 });
	addRect('longRect', { x: 0.2, y: 0.2 });
	addRect('longerRect', { x: 0.2, y: 0.2, z: .7 });
	addRect('cube');
	addPyramid('pyramid');
	addPyramid('longPyramid', { y: .8 });
	addSphere('sphere');
	addSphere('simpleSphere', { precision: 6 });
	addSphere('ufo', { y: 3, precision: 10 });
	// addRect('rect', { y: 1 });

	sys = makeStarSystem(W, SPACE_SIZE, textures);
	['renderables', 'ship'].forEach((k) => {
		window[k] = sys[k];
		g[k] = sys[k];
	});

	const ks = Object.entries(renderables).filter(([,o]) => o.isKlax);
	ks.forEach(([,o], i) => {
		if (o.isKlax) {
			const n = `scan${i}`;
			const scan = { n, g: 'system', x: o.x, y: o.y, z: o.z, size: SCAN_SIZE, t: textures.scan };
			renderables[n] = scan;
			W.billboard(scan);
		}
	});
	g.ogKlaxShipCount = g.klaxShipLeft = ks.length;
	achieve();
}

function thrust(o, amount = 0) {
	const { x, y, z } = getDirectionUnit(o).scale(amount);
	o.thrust = { x, y, z};
}

function outOfBounds(o) {
	const boundDirs = ['x', 'y', 'z'].filter((a) => o[a] >= SPACE_SIZE || o[a] <= -SPACE_SIZE);
	return boundDirs.length > 0;
}

function physics(o, sec) {
	// If no thrust then apply friction (unrealistic in space? let's blame it on lots of star dust)
	let { friction = 1 } = o;
	friction *= VEL_FRICTION;
	if (outOfBounds(o)) friction *= 10;
	// const friction = (typeof o.friction === 'number') ? VEL_FRICTION * o.friction : VEL_FRICTION;
	const velVector = vec3(o.vel);
	const F = vec3(o.thrust || undefined);
	const acc = F.scale(1 / (o.mass || 1));
	o.vel = velVector
		.sub(velVector.normalize(friction)) // friction is an acceleration of sorts, not mass dependent
		.add(acc.scale(1/sec)); // add acceleration per time
	const spd = o.vel.length();
	if (spd > MAX_VEL) o.vel = o.vel.normalize(MAX_VEL);
	else if (spd < 0.0001) o.vel = vec3();
	['x', 'y', 'z'].forEach((a) => {
		// This "* sec" calculation seems wrong but don't want to mess with it right now
		o[a] = clamp(o[a] + o.vel[a] * sec, -SPACE_SIZE, SPACE_SIZE);
		if (outOfBounds(o)) {
			if (o.decay) o.decay = 0;
			// console.log(o.n, 'edge');
		}
	});
}

function dmg(a, b) { // a = attacker, b = defender
	if (a.damage && b.hp) {
		const isShipHurt = (b === ship);
		const shieldPercent = clamp((b.shields || 0) / 100, 0, 1);
		b.hp -= (a.damage * (1 - shieldPercent));
		// console.log('Shield %', shieldPercent, '\n', b);
		if (a.destroyOnDamage) a.decay = 0;
		if (b.hp <= 0) {
			// console.log('Destroy', b.n);
			b.decay = 0;
			if (b.drops) {
				b.drops.forEach((drop) => ship.inv[drop] = (ship.inv[drop] || 0) + 1);
			}
			if (b.explodes) spawnExplosion(b, b.explodes);
		} else {
			spawnExplosion({ x: b.x, y: b.y, z: b.z }, { count: 8 });
		}
		const vol = isShipHurt ? 1.5 : .7;
		zzfx(...[vol,,416,.02,.21,.52,4,2.14,.2,,,,,1.7,,.9,,.44,.12,.23]);
		if (isShipHurt) flashBorder('canvas');
	}
	a.aggro += 1;
	b.aggro += 1;
};

function collide(e1, e2, dist) {
	// Set flags
	e1.collided = e2;
	e2.collided = e1;
	// Damage
	dmg(e1, e2);
	dmg(e2, e1);
	// Un-overlap
	const collisionVector = vec3(e2).sub(e1).normalize();
	const overlap = e1.r + e2.r - dist;
	// Move each sphere back by half the overlap
	const reverseOverlapVector = collisionVector.scale(overlap / 2);
	vec3(e1).sub(reverseOverlapVector).copyTo(e1);
	vec3(e2).add(reverseOverlapVector).copyTo(e2);
	// Set new velocities
	['x', 'y', 'z'].forEach((a) => {
		const m1 = e1.mass || 1;
		const m2 = e2.mass || 1;
		const tm = m1 + m2; // total mass
		const v1 = e1.vel[a];
		const v2 = e2.vel[a];
		// From https://en.wikipedia.org/wiki/Elastic_collision#Equations
		e1.vel[a] = (
			((m1 - m2) / tm) * v1
			+ ((2 * m2) / tm) * v2
		) * 1; // restitution
		e2.vel[a] = (
			((2 * m1) / tm) * v1
			+ ((m2 - m1) / tm) * v2
		) * 1;
		// console.log(a, 'before', v1, v2, '\nafter', e1.vel[a], e2.vel[a]);
	});
}

function pass(a, b) {
	return (a.p !== PHYSICS_COLLIDABLE || b.p !== PHYSICS_COLLIDABLE
		|| (a.passthru && a.passthru.includes(b.passType)));
}

function checkCollision(e1, ents) {
	if (e1.collided || e1.p !== PHYSICS_COLLIDABLE) return;
	loop(ents.length, (w) => {
		const e2 = ents[w];
		if (pass(e1, e2) || pass(e2, e1) || e1 === e2)  return;
		if (e2.collided) return;
		const d = vec3(e1).distance(e2);
		if (d <= (e1.r + e2.r)) collide(e1, e2, d);
	});
}

function cool(o, prop, sec) {
	o[prop] = max(o[prop] - sec, 0);
}

function steerRotation(o, steer, strafe = 0) {
	const { steerPercent = 0.01 } = o;
	['rx', 'ry', 'rz'].forEach((k) => o[k] = lerp(steerPercent, o[k], steer[k]));
	// console.log(o.ry, strafe, o.ry + strafe, steer.ry);
	if (strafe) o.ry = lerp(0.1, o.ry, steer.ry + strafe);
}

function updateKlaxShip(k, sec) {
	if (k.decay <= 0 || k.hp <= 0) {
		// console.warn('destroyed ship');
		return;
	}
	const pos = vec3(k);
	const dist = pos.distance(ship);
	if (dist > k.sight * 2) k.aggro = max(0, k.aggro -= 0.1);
	else if (dist <= k.sight) k.aggro = max(1, k.aggro);
	if (!k.aggro) return;
	// Aggro actions
	const steer = pos.toWAngles(ship);
	steerRotation(k, steer);
	// k.rx = lerp(0.01, k.rx, rx);
	// k.ry = lerp(0.01, k.ry, ry);
	// k.rz = lerp(0.01, k.rz, rz);
	if (k.thrustCooldown) {
		cool(k, 'thrustCooldown', sec);
	} else {
		thrust(k, k.thrustForce);
		k.thrustCooldown = rand(.5, 1);
	}
	if (k.fireCooldown) {
		cool(k, 'fireCooldown', sec);
	} else {
		spawnPlasma('klaxPlasma', k, 'klaxPlasma', ['klaxShip', 'klaxPlasma', 'plasma']);
		k.fireCooldown = rand(0.3, 3);
	}
}

const basePlasmaThrustScale = .001;
const PROJECTILE_TYPES = {
	plasma: { vScale: 45, tScale: basePlasmaThrustScale * 4, damage: 1, size: 2,
		sound: [,.1,295,.02,.01,.08,,1.72,-3.5,.2,,,,.2,,,.08,.62,.09] },
	photon: { vScale: 25, tScale: basePlasmaThrustScale * 1.2, damage: 3, size: 2,
		sound: [2.06,.35,212,.05,.08,.01,,1.66,-4.8,.2,50,,,1.7,,.5,.28,.65,.02] },
	klaxPlasma: { vScale: 45, tScale: basePlasmaThrustScale * 2, damage: 1, size: 10,
		sound: [.3,.4,241,.04,.03,.08,,.46,-7.7,,,,,,,.2,,.53,.05,.2],
	},
};

function spawnPlasma(typeKey, from, passType, passthru) {
	const { vScale, tScale, damage, size, sound } = PROJECTILE_TYPES[typeKey];
	// if (tScale < VEL_FRICTION) console.warn('Not enough thrust to overcome friction');
	const t = textures[typeKey];
	const u = getDirectionUnit(from);
	const { x, y, z } = vec3(from).add(u.normalize(from.size));
	const v = u.scale(vScale).add(from.vel);
	zzfx(...sound);
	const plasma = {
		n: typeKey + passType + uid(),
		g: 'system',
		passType,
		x, y, z,
		vel: { ...v },
		thrust: { ...u.scale(tScale) },
		// friction: 0,
		decay: 5,
		damage,
		r: 5,
		passthru,
		mass: 0.01,
		size,
		destroyOnDamage: 1,
		p: PHYSICS_COLLIDABLE,
	};
	renderables[plasma.n] = plasma;
	W.billboard({ ...plasma, t });
}

function spawnExplosion(where, explodes) {
	let { x, y, z } = where;
	const {
		count = 20, size = 2, colors = ['464040', 'de8b6f', 'b0455a'], maxDecay = 10
	} = explodes || where.explodes || {};
	// console.log('Exploding for', where.n, count);
	loop(count, () => {
		const vel = vec3(where.vel || { x: 0, y: 0, z: 0 });
		['x', 'y', 'z'].forEach((w) => {
			vel[w] += rand(-20, 20);
		});
		const explosion = {
			n: `explosion${uid()}`,
			x: x + rand(-.5, .5),
			y: y + rand(-.5, .5),
			z: z + rand(-.5, .5),
			vel,
			decay: rand(1, maxDecay),
			r: 1,
			g: 'system',
			size: max(size + rand(-size/2, size/2), .2),
			passType: 'dust',
			passthru: ['dust'],
			mass: 0.01,
			b: pick(colors),
			destroyOnDamage: 1,
			p: PHYSICS_NON_COLLIDABLE,
		};
		renderables[explosion.n] = explosion;
		W.billboard({ ...explosion });
	});
}

function spawnTrail(o, sec) {
	if (o.trailCooldown) {
		cool(o, 'trailCooldown', sec);
		return;
	}
	ship.trailCooldown = 0.1;
	if (vec3(o.vel).length() === 0) return;
	const { x, y, z } = o;
	const trail = {
		n: `${o.n}trail${uid()}`,
		x, y, z,
		decay: 10,
		g: 'system',
		size: rand(.1, .3),
		b: '7666',
	};
	renderables[trail.n] = trail;
	W.billboard({ ...trail });
}

function htmlLine(n, m) {
	let h = '';
	loop(Math.floor((n/m) * 10), () => h += '-');
	return h;
}

function updateUI() {
	const v = vec3(ship.vel);
	const dir = (v.x > v.y && v.x > v.z) ? 'X' : (
		(v.y > v.x && v.y > v.z) ? 'Y' : 'Z'
	);
	const spd = v.length();
	const html = (g.paused ? '<b>Paused</b>' : '') + '<b>' + [
		`Velocity: ${round(spd)} (${dir}) ${htmlLine(spd, MAX_VEL)}`,
		// `Pitch: ${round(steer.rx + 90)}, Yaw: ${round(steer.ry) % 360}`,
		`Power: ${floor(ship.power)} ${htmlLine(ship.power, ship.maxPower)}`,
		`Shields: ${floor(ship.shields)} ${htmlLine(ship.shields, 100)}`,
		`Hull: ${floor(ship.hp * 10) / 10} ${htmlLine(ship.hp, ship.maxHp)}`,
	].join('</b><b>') + '</b>';
	$html('si', html);
}

function zoom(n) {
	camOffset.zoom = clamp(camOffset.zoom + n, 0, 100);
}

function playDud() {
	zzfx(...[.5,,144,.01,.04,.17,1,.77,,,-119,.09,,,31,.1,,.84,.03,.06]);
}

function update() {
	if (g.paused) return;
	g.tick++;
	if (g.tick > 100000) g.tick = 0;
	const sec = t / 1000;
	rotation = (rotation + sec) % 360;

	// Handle inputs and update player ship
	const { down } = input;
	if (down[']']) cam.targetFov += .5;
	if (down['[']) cam.targetFov -= .5;
	const wheel = input.getWheel();
	if (down['-'] || wheel > 0) zoom(.1);
	if (down['='] || down['+'] || wheel < 0) zoom(-.1);
	if (down.p) return;
	const strafe = (down.a) ? 90 : (down.d ? -90 : 0);

	const boost = down.Shift ? 2 : 1;
	let thrustAmount = 0; 
	if (boost > 1) achieve(4);
	if (ship.power <= 0) {
		// 
	} else if (down.s) {
		thrustAmount = ship.thrustForce * boost * -.5;
		down.w = 0;
	} else if (down.w) {
		thrustAmount = ship.thrustForce * boost;
	}
	thrust(ship, thrustAmount);
	{
		const flameColor = (thrustAmount > 0) ? FLAME_ON_COLOR : FLAME_OFF_COLOR;
		W.move({ n: 'sFlame1', b: flameColor });
		W.move({ n: 'sFlame2', b: flameColor });
		ship.ignition = lerp(0.2, ship.ignition, (thrustAmount) ? ship.ignitionSize : 0.0001);
		W.move({ n: 'sIgnite1', size: ship.ignition, y: SHIP_SIZE * (thrustAmount < 0 ? .6 : -1.31) });
		W.move({ n: 'sIgnite2', size: ship.ignition, y: SHIP_SIZE * (thrustAmount < 0 ? .6 : -1.31)  });
	}
	if (thrustAmount) {
		ship.power -= ship.enginePowerUsage;
		const vol = (boost > 1) ? .15 : .1;
		const bitCrush = (boost > 1) ? .2 : .8;
		zzfx(...[vol,,794,.02,.3,.32,,3.96,,.7,,,.16,2.1,,bitCrush,.1,.31,.27]);
		achieve(2);
	}
	
	const click = input.getClick();
	if (ship.fireCooldown === 0	&& (down.f || down.r || (click && click.locked))) {
		achieve(3);
		if (ship.power < ship.weaponPowerUsage) {
			playDud();
		} else {
			ship.power -= ship.weaponPowerUsage;
			spawnPlasma(
				(click && click.right || down.r) ? 'photon' : 'plasma',
				ship,
				'plasma',
				['ship', 'plasma', 'klaxPlasma'],
			);
			ship.fireCooldown = 0.3;
		}
	}
	if (down[' ']) {
		if (ship.power > 12) { // min power needed to power shields
			const chargeUp = min(ship.power, ship.shieldPower - ship.shields);
			ship.shields += chargeUp;
			ship.power -= chargeUp;
			zzfx(...[.4,,99,,.23,.12,3,1.07,,5,,,.06,,,1,,.7,.24,.32]);
			achieve(5);
		} else playDud();
	}
	// For testing
	if (down.y) spawnExplosion(ship, ship.explodes);
	// Scan (animations happen below)
	if (down.c) achieve(1); 

	// Get arrays of physics entities and enemy ships
	const physicsEnts = [ship];
	const klaxShips = [];
	Object.entries(renderables).forEach(([,o]) => {
		if (o.p) physicsEnts.push(o);
		if (o.isKlax) klaxShips.push(o);
	});
	g.klaxShipLeft = klaxShips.length;

	// Do enemy thrust, rotation, cooldowns, and AI
	klaxShips.forEach((k, i) => {
		updateKlaxShip(k, sec);
		// Update scan
		const scan = (down.c && k.hp > 0) ? {
			x: k.x, y: k.y, z: k.z,
			size: 110, b: SCAN_COLOR,
		} : {
			size: .1, b: '0000',
		};
		renderables[`scan${i}`] = { ...renderables[`scan${i}`], ...scan };
	});

	// Do collisions
	loop(physicsEnts.length, (i) => checkCollision(physicsEnts[i], physicsEnts));
	// Do physics, and clear collided flag
	physicsEnts.forEach((o) => {
		o.collided = 0;
		physics(o, sec);
	});

	// Player cool down and recharge
	ship.fireCooldown = max(ship.fireCooldown - sec, 0);
	ship.power = min(ship.maxPower, ship.power + ship.recharge);
	ship.shields = max(0, ship.shields - ship.shieldsDecayAmount);

	// Check for player death
	if (ship.hp <= 0) {
		ship.size = .01;
		spawnExplosion(ship);
		(async () => {
			await wait(1500);
			return gameOver();
		})();
	}
	
	
	// Player Ship Steering
	{
		// const { ry, rx } = steer;
		const lockMove = input.getLockMove();
		// if (lockMove.x || lockMove.y) console.log(lockMove);
		steer.ry -= lockMove.x / 10;
		steer.rx = min(max(steer.rx - lockMove.y / 10, STEER_X_MIN), STEER_X_MAX);
		// steer.rz += down.a ? -2 : (down.d ? 2 : 0);
		// console.log({ ...steer });
		steerRotation(ship, steer, strafe);
	}
	{
		const unit = rotateByDegree(
			vec3(0, camOffset.back, camOffset.up).scale(camOffset.zoom), steer);
		// TODO: only add cam if fov or aspect ratio has changed
		const speedFov = (!thrustAmount) ? 0 : (
			thrustAmount < 0 ? -2 : (
				(boost > 1) ? 10 : 1
			)
		);
		cam.fov = lerp(0.1, cam.fov, cam.targetFov + speedFov);
		const fovChanged = abs(cam.fov - cam.lastFov) > 0.001;
		cam.lastFov = cam.fov;
		let camSettings = { ...unit, ...addAngles(camOffset, steer), a: t };
		if (fovChanged) camSettings = { ...camSettings, ...cam };
		W.camera(camSettings);
	}

	if (g.trail) spawnTrail(ship, sec);

	// Decay
	// Note: This has to be done towards the end because we're not removing the objects from the
	// physics array or klax ship array
	Object.keys(renderables).forEach((k) => {
		const p = renderables[k];
		if (typeof p.decay === 'number') {
			p.decay -= sec;
			if (p.decay <= 0) {
				if (p.isGroup) {
					// We don't know the group's children, so we can't just delete the group
					// otherwise the children will still get rendered
					W.move({ n: p.n, x: FAR * 2 });
				} else {
					W.delete(p.n);
				}
				delete renderables[k];
				achieve();
			}
		}
	});

	// Animate the system and renderables
	const shieldOp = clamp(ship.shields, 10, 99);
	W.move({ n: 'sShield', b: `de8b6f${shieldOp}`, size: ship.shields ? 1.2 : 0.01, a: 100 });
	const allMovingThings = {
		ship: { ...ship, x: 0, y: 0, z: 0 },
		...renderables,
		system: { x: -ship.x, y: -ship.y, z: -ship.z, a: t },
		...updateSystem(t),
	};
	Object.keys(allMovingThings).forEach((key) => {
		W.move({ n: key, ...allMovingThings[key], a: t }, 0);
	});

	if (g.tick % 4 === 0) updateUI();
}

addEventListener('DOMContentLoaded', async () => {
	setup();
	await wait(30);
	update();
	await wait(30);
	title();
	// titleDone();
	g.start();
});

window.g = g;
